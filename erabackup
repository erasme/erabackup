#!/usr/bin/perl

require "./Job.pl";

#use ERASME::Backup::Job;
use Config::General;
use Getopt::Std;
use Sys::Hostname;
use POSIX qw(ceil floor);

use Mail::Sendmail;

use Data::Dumper;

use strict;

our $VERSION = "1.0";

our %CONF;
our @JOBS;
our @FINISHED;
our %OPTS;
#our @PRIOLIST;
our $CMDLINE;

$| = 1;


sub read_config {
	print STDERR "[backp] Reading config " . $OPTS{"config"} . "\n";

	if (! -r $OPTS{"config"}) {
		print "Unable to open config file " . $OPTS{"config"} . "\n";
		exit;
	}

	my $conf = new Config::General($OPTS{"config"});

	%CONF = $conf->getall;

	return 1;
}


sub create_jobs {
	my $job;

	foreach my $target (keys %CONF) {
		if (ref $CONF{$target} eq "HASH") {
			$job = ERASME::Backup::Job->new($target);
			$job->initialize($CONF{$target});
			$job->dryrun($OPTS{"dry-run"});
			$job->options($OPTS{"options"});
			push @JOBS, $job;
		} else {
			# Global option
			$OPTS{$target} = $CONF{$target};
		}
	}

#	print Dumper(\@JOBS);
	print Dumper(\%OPTS);
}

sub sort_targets {
	@JOBS = sort { $a->priority() <=> $b->priority() } (@JOBS);

	print STDERR "[sched] Targets will be backed up in this order : ";

	foreach my $job (@JOBS) {
		print STDERR $job->host() . " ";
	}

	print "\n";
}

sub get_states {
	my %states;

	foreach my $job (@JOBS) {
		$states{$job->status()}++;
	}

	return \%states;
}

sub get_running {
	my $running = 0;

	$running = scalar &get_states->{"RUNNING"};

#	foreach my $job (@JOBS) { $running++ if $job->is_running(); }

	if ($running > 0) {
		print STDERR "[sched] $running jobs running\n";
	}

	return $running;
}

sub do_join {
		foreach my $job (@JOBS) { 
			if ($job->is_joinable()) {
				$job->end();
				push @FINISHED, $job;
			}
		}
}

sub write_status {
	my $states = &get_states;
	my $tempfile = $OPTS{'status-file'} . ".tmp";
	my $total;

	my $statestr;

	open (STATE, ">" . $OPTS{'status-file'} . ".tmp");

	print STATE "#\n# erabackup status file, generated " . scalar localtime time;
	print STATE "\n#\n# invoked with : $CMDLINE";

	foreach my $st (keys %{$states}) {
		$total += $states->{$st};
		$statestr .= $states->{$st} . " $st, "
	}

	chop $statestr;	chop $statestr;

	print STATE "\n# $total jobs ($statestr), " . floor(($states->{"TERMINATED"} + $states->{"DISABLED"}) * 1000 / $total) / 10 . "% done\n";
	print STATE "#\n# JobName, Thread, Status, Create, Started, Finished\n#\n";

	foreach my $job (@JOBS) {
		print STATE $job->id() . "," . $job->tid() . "," . $job->status() . "," . $job->create_time() . "," . $job->start_time() . "," . $job->end_time() . "\n";
	}

	close STATE;

	rename $tempfile, $OPTS{'status-file'};
}

sub run_backup {
	my @joblist=@JOBS;
	my $states;

	do {
		if (&get_running < $OPTS{"processes"}) {
			my $job = shift @joblist;
			print STDERR "[sched] starting job\n";
			$job->start();
			&write_status;
		} else {
			sleep 1;
			&do_join;
		}
	} while (scalar @joblist);

	do {
		$states = &get_states;
		&write_status;
		&do_join;
	} while ($states->{"RUNNING"} + $states->{"CLOSING"});
}

sub gen_report {
	my $report;
	my @parts;

	$report .= "############################################\n";
	$report .= "######### B a c k u p  R e p o r t #########\n";
	$report .= "############################################\n";

	foreach my $job (sort { $a->id() cmp $b->id() } @JOBS) {
		$report .= "\nJob " . $job->id() . "\n";

		$report .= '-'x(length($job->id())+5) . "\n";

		if (!$job->enabled()) {
			$report .= "\n  disabled\n";
			next;
		}

		$report .= "\n  created " . scalar localtime $job->create_time();

		$report .= "\n  thread id " . $job->tid();
		$report .= "\n  command " . $job->command();

		$report .= "\n\n  started " . scalar localtime $job->start_time();
		$report .= "\n  ended " . scalar localtime $job->end_time();

		@parts = gmtime($job->end_time() - $job->start_time());

		$report .= sprintf ("\n\n  run time : %d secs (%1dd%3dh%3dm%3ds)\n",($job->end_time() - $job->start_time()),@parts[7,2,1,0]);
		$report .= "\n  output : " . $job->result() . "\n";
	}

	$report .= "\n";

	return $report;
}

sub show_status {
	my $file = shift;

	my @fields;
	my @parts;

	my $lasttime = 0;

	if (!defined $file) {
		my @files = glob("/tmp/erabackup.stat.*");

		foreach my $f (@files) {
			if ((stat($f))[9] > $lasttime) {
				$lasttime = (stat($f))[9];
				$file = $f
			}
		}

		print "#\n# Status file autodetected : $file\n# (last modified " . scalar localtime $lasttime;
		print ")\n";
	}

	open(STAT, "<$file") or die "Error : unable to open status file $file";

	while(<STAT>) {
		if (/^#/) { print; next; }
		@fields = split /,/;
		if (($fields[5]-$fields[4]) > 0) {
			@parts = gmtime($fields[5]-$fields[4]);
			printf ("%20.20s => %3dd%3dh%3dm%3ds\n",$fields[0],@parts[7,2,1,0]);
		} else {
			@parts = gmtime(time-$fields[4]);
			printf ("%20.20s => %3dd%3dh%3dm%3ds (still running)\n",$fields[0],@parts[7,2,1,0]); 
		}
	}

	print "\n";
}

sub help {
	print "\nerabackup version $VERSION\n\n";
	print "Usage :\n";
	print "  erabackup [-c config] [-p nthreads] [-s statusfile] [-m recipient] [-n] [-o \"options\"] [-h] [-d [statusfile]]\n\n";

	print "   -c config       : use config as configuration file (default is /etc/erabackup.conf)\n";
	print "   -p nthreads     : use nthreads number of parallel threads for backup (default is 2)\n";
	print "   -s statusfile   : use statusfile as status file during backup (default is /tmp/erabackup.stat.PID)\n";
	print "   -m recipient    : send email report to recipient when done (default is to output report to STDOUT)\n";
	print "   -n              : dry run, simulation mode.\n";
	print "   -o \"options\"    : append \"options\" to bontmia command (e.g. \"--bwlimit 250\").\n";
	print "   -d [statusfile] : displays backup progress for statusfile. If no statusfile specified, will use the most recent /tmp/erabackup.stat.*\n";
	print "   -h              : show this help\n\n";
}

sub parse_cli {
	my %opts;

	$OPTS{'config'} = "/etc/erabackup.conf";
  $OPTS{'processes'} = 2;
	$OPTS{'status-file'} = "/tmp/erabackup.stat.$$";
	$OPTS{'mail-to'} = undef;

	getopts('np:c:o:s:m:hd:', \%opts);

	if (defined $opts{'h'}) {
		&help;
		exit;
	}

	if (exists $opts{'d'}) {
		&show_status($opts{'d'});
	}

  $OPTS{"config"}      = $opts{'c'} if defined $opts{'c'};
  $OPTS{"processes"}   = $opts{'p'} if defined $opts{'p'};
  $OPTS{"options"}     = $opts{'o'};
  $OPTS{"dry-run"}     = $opts{'n'};
  $OPTS{"status-file"} = $opts{'s'} if defined $opts{'s'};
	$OPTS{"mail-to"}     = $opts{'m'} if defined $opts{'m'};
}

sub main {
	$CMDLINE = join(" ", @ARGV);

	&parse_cli;

	print STDERR "[backp] Starting backup process with " . $OPTS{"processes"} . " slots \n";

	&read_config;

	print Dumper(\%CONF);

	&create_jobs;

	&sort_targets;

	&run_backup;

	print STDERR "[backp] Backup done.\n\n";

	if (defined $OPTS{"mail-to"}) {
		my %mail;

		%mail = ( To   => $OPTS{"mail-to"},
							From => getlogin() . '@' . hostname(),
							Subject => "Backup report",
							Message => &gen_report );

		unshift @{$Mail::Sendmail::mailcfg{'smtp'}} , $OPTS{'smtp_server'};

		sendmail(%mail) || print "Error sending mail: $Mail::Sendmail::error\n";
	} else {
		print &gen_report;
	}
}


&main;





